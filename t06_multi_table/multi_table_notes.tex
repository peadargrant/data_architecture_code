\chapter{Multi-table Databases}
\label{ch:multi-table-databases}

\section{Recommended reading}

\begin{enumerate}
\item
  Connolly \& Begg Chapters 4,5
\item
  PostgreSQL manual chapters as identified in this document.
\end{enumerate}

\section{Relational model}\label{relational-model}

Relational model is based on mathematical concept of a relation. DBMS
applies this as a table.

\begin{description}
\item[Relation:]
a \textbf{table} with rows and columns. Logically must appear to user in
this form. Physical storage on disk may differ.
\item[Attribute:]
named \textbf{column} of a relation
\item[Domain:]
set of \textbf{allowable values} for one or more attributes
\item[Tuple:]
\textbf{row} of a relation. Also called \textbf{record}.
\item[Degree]
of a relation is the number of attributes that it contains.
\item[Cardinality:]
of a relation is the \textbf{number of tuples} that it contains.
\end{description}

\section{Foreign keys}\label{foreign-keys}

\href{https://www.postgresql.org/docs/13/ddl-constraints.html\#DDL-CONSTRAINTS-FK}{Foreign
keys} require that values in a column (or a group of columns) must match
the values appearing in some row of another table. This maintains the
referential integrity.

\begin{minted}{postgresql}
/* each employee must be in a valid department */

CREATE TABLE department (
id bigserial primary key,
name text not null unique
/* other fields as required */
);

CREATE TABLE employee (
id bigserial primary key,
surname text not null,
firstname text not null,
department bigint not null REFERENCES department
/* other fields as required */
)
\end{minted}

\subsection{DELETE / UPDATE behaviour}\label{delete-update-behaviour}

Possible behaviours: NO ACTION, CASCADE, SET NULL.

\begin{minted}{postgresql}
CREATE TABLE product ( 
/* other fields */

department bigint references departments, 
/* NO ACTION is the default, prohibits conflicting delete */

supplier bigint references suppliers ON DELETE CASCADE,
/* DELETE in suppliers deletes linked products */

policy bigint references policies ON DELETE SET NULL,
/* SETS product.policy to NULL when row in policies deleted  */

);
\end{minted}

\section{JOIN}\label{join}

The JOIN operation permits queries across more than one table. See both
the
\href{https://www.postgresql.org/docs/current/tutorial-join.html}{JOIN
tutorial} and the
\href{https://www.postgresql.org/docs/13/queries-table-expressions.html}{Table
expressions} section from Postgres manual for full details.

Assume R1 to be a row of Table T1. Similarly R2 for T2. Normally should
explicitly specify columns required and use table prefix to avoid
ambiguity.

\subsection{INNER JOIN}\label{inner-join}

For each row R1 of T1, the joined table has a row for each row in T2
that satisfies the join condition with R1.

\subsection{LEFT JOIN}\label{left-join}

Same as INNER JOIN except that output also includes any row in T1 that
does not match one or more rows in T2. Null values are substituted for
T2 in the output row.

\subsection{RIGHT JOIN}\label{right-join}

Similar to LEFT JOIN. Same as INNER JOIN, except any row in T2 that does
not match \(\ge 1\) rows in T1 will be output. Null values are
subtituted for T1 columns in the otuput row.

\subsection{FULL JOIN}\label{full-join}

Similar to combination of LEFT and RIGHT JOIN. INNER JOIN performed.
Then rows in T1 without corresponding T2 output with nulls for T2. Same
again, rows in T2 without corresponding T1 rows output with nulls for
T1.

\section{CASE clause}\label{case-clause}

\href{https://www.postgresql.org/docs/13/functions-conditional.html\#FUNCTIONS-CASE}{CASE}
permits conditionals in select statement outputs.

\begin{minted}{postgresql}
/* using case statement */ 
SELECT account_id, balance, limit,
CASE 
WHEN balance>limit then 'OVERDRAWN' 
WHEN balance=0 THEN 'ZERO' 
ELSE 'OK' 
END AS status
FROM accounts /* rest of query */
;
\end{minted}

\section{Views}\label{sec:views}

\href{https://www.postgresql.org/docs/13/tutorial-views.html}{Views} are
defined by @connolly:2015:database as:

\begin{quote}
The dynamic result of one or more relational operations operating on the
base relations to produce another relation. A view is a virtual relation
that does not necessarily exist in the database but can be produced upon
request by a particular user, at the time of the request.
\end{quote}

\begin{minted}{postgresql}
/* Creation syntax: */
CREATE VIEW my_view AS
SELECT ... ;
/* select statement can be any valid select */

/* VIEW can be selected like any other table */
SELECT * FROM my_view ; 
\end{minted}

\section{Domains}\label{sec:domains}

\href{https://www.postgresql.org/docs/13/domains.html}{Domains} are
user-defined types based on underlying type. Defaults to NULL allowed,
best to define any NOT NULL conditions on the underlying columns. CHECK
constraints can be defined.

\begin{minted}{postgresql}
/* Number to hold 1-10 user rating */
CREATE DOMAIN rating AS integer CHECK ( VALUE >= 1 AND VALUE <=10 );

/* Just use the domain as type when creating table */
CREATE TABLE restaurants (
    id bigserial primary key,
    /* creating two columns using our domain: */
    visitor_rating rating not null,
    reviewer_rating rating, 
    /* other columns */
);
\end{minted}

\section{Enumerated types}\label{sec:enumerated-types}

\href{https://www.postgresql.org/docs/13/datatype-enum.html}{Enumerated
types} allow columns to accept a small number of allowable values.
Examples include day of week, identified gender, north / south / east /
west.

\begin{minted}{postgresql}
/* creating an enumerated type */
CREATE TYPE mood AS ENUM ( 'sad', 'ok', 'happy');

/* creating column using enumerated type  */
ALTER TABLE people ADD COLUMN reported_mood mood;
\end{minted}

\section{Lab exercise}


Consider a simple task manager application using two tables for projects, tasks (linked to projects) and notes (linked to tasks)
\begin{description}
\item[Projects] have auto-incrementing ID, name, creation timetstamp.
\item[Tasks] have auto-incrementing ID, description, project, due date, creation timestamp, status (pending, in-progress, complete).
\item[Notes] have auto-incrementing ID, task, note, creation timestamp
\end{description}

\begin{enumerate}
\item On paper, plan out the table definitions.
  \begin{enumerate}
  \item Every table should have appropriate data types, NULL/NOT NULL, PRIMARY KEY, UNIQUE KEYs.
  \item You should try to make use of enumerated types and domains.
  \item Tables should be linked using foreign keys with correct ON DELETE / ON UPDATE behaviours chosen.
  \end{enumerate}
\item Implement your design as tables.
\item Insert test data for at least 3 projects with 3 tasks each. 
\item Create a view that encapsulates a query involving at least two tables and provides at least one computed column using the CASE clause. 
\end{enumerate}



